// Generated by LiveScript 1.3.1
(function(){
  var async, fs, cp, gulp, ls, less, eventemitter2, EventEmitter2, dft;
  async = require('async');
  fs = require('fs');
  cp = require('child_process');
  gulp = require('gulp');
  ls = require('gulp-livescript');
  less = require('gulp-less');
  eventemitter2 = require('eventemitter2');
  EventEmitter2 = eventemitter2.EventEmitter2;
  dft = function(){
    var log, clear, build, start, watch;
    log = function(msg, tab){
      var _msg, i$, i;
      _msg = msg;
      tab = tab || 0;
      for (i$ = 0; i$ < tab; ++i$) {
        i = i$;
        _msg = '    ' + _msg;
      }
      console.log(_msg);
    };
    clear = function(cb){
      cp.exec('rm ../bin -r', function(){
        log('cleared.', 0);
        cb();
      });
    };
    build = function(){
      var compileAll, copyAll;
      compileAll = function(){
        var _compile, compileLs, compileLess;
        _compile = function(srcPath, destPath, compiler, cb){
          gulp.src(srcPath).pipe(compiler).pipe(gulp.dest(destPath)).on('end', cb);
        };
        compileLs = function(){
          var compileServer, compilePublic;
          compileServer = function(cb){
            async.parallel([
              function(cb){
                _compile('app.ls', '../bin', ls(), cb);
              }, function(cb){
                _compile('run.ls', '../bin', ls(), cb);
              }, function(cb){
                _compile('routes/**/*.ls', '../bin/routes', ls(), cb);
              }
            ], cb);
          };
          compilePublic = function(cb){
            _compile('views/**/*.ls', '../bin/public', ls(), cb);
          };
          return function(cb){
            async.parallel([compileServer, compilePublic], cb);
          };
        }();
        compileLess = function(cb){
          _compile('views/**/*.less', '../bin/public', less(), cb);
        };
        return function(cb){
          async.parallel([compileLs, compileLess], cb);
        };
      }();
      copyAll = function(){
        var copyJade, copyAssets;
        copyJade = function(cb){
          gulp.src('views/**/*.jade').pipe(gulp.dest('../bin/views')).on('end', cb);
        };
        copyAssets = function(cb){
          gulp.src('../assets/**/*').pipe(gulp.dest('../bin/public')).on('end', cb);
        };
        return function(cb){
          async.parallel([copyJade, copyAssets], cb);
        };
      }();
      return function(cb){
        async.parallel([compileAll, copyAll], function(err){
          log('builded.', 0);
          cb(err);
        });
      };
    }();
    start = function(){
      var serverProcess;
      serverProcess = null;
      return function(cb){
        serverProcess && serverProcess.kill();
        serverProcess = cp.spawn('node', ['../bin/run.js'], {
          cwd: '../bin'
        });
        serverProcess.stdout.on('data', function(chunk){
          console.log(chunk.toString());
        });
        serverProcess.stderr.on('data', function(chunk){
          console.error(chunk.toString());
        });
        log('started.', 0);
        cb();
      };
    }();
    watch = function(){
      var eventBus, watchServer, watchPublic;
      eventBus = new EventEmitter2;
      eventBus.on('restart', function(cb){
        async.series([clear, build, start], cb);
      });
      eventBus.on('rebuild', function(cb){
        async.series([clear, build], cb);
      });
      watchServer = function(){
        var paths;
        paths = ['app.ls', 'run.ls', 'config.json', 'router/*.ls'];
        paths.forEach(function(path){
          gulp.watch(path, function(){
            eventBus.emit('restart');
          });
        });
      };
      watchPublic = function(){
        var paths;
        paths = ['views/**/*.less', 'views/**/*.less'];
        paths.forEach(function(path){
          gulp.watch(path, function(){
            eventBus.emit('rebuild');
          });
        });
      };
      return function(cb){
        watchServer();
        watchPublic();
        log('watching..', 0);
        cb();
      };
    }();
    return function(cb){
      async.series([clear, build, start, watch], cb);
    };
  }();
  gulp.task('default', dft);
}).call(this);
